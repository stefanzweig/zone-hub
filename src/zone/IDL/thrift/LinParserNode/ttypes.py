#
# Autogenerated by Thrift Compiler (0.19.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
sys.path.append("..")
from zone.IDL.thrift.CommonNode import ttypes as CommonNode_ttypes

from thrift.transport import TTransport
all_structs = []


class linNodeConfig(object):
    """
    Attributes:
     - nodeName: string
    	LIN节点名字
     - channel: int32
    	LIN节点所在的软件通道
     - simu: bool
    	LIN节点是否仿真标志位

    """


    def __init__(self, nodeName=None, channel=None, simu=None,):
        self.nodeName = nodeName
        self.channel = channel
        self.simu = simu

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nodeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.channel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.simu = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linNodeConfig')
        if self.nodeName is not None:
            oprot.writeFieldBegin('nodeName', TType.STRING, 1)
            oprot.writeString(self.nodeName.encode('utf-8') if sys.version_info[0] == 2 else self.nodeName)
            oprot.writeFieldEnd()
        if self.channel is not None:
            oprot.writeFieldBegin('channel', TType.I32, 2)
            oprot.writeI32(self.channel)
            oprot.writeFieldEnd()
        if self.simu is not None:
            oprot.writeFieldBegin('simu', TType.BOOL, 3)
            oprot.writeBool(self.simu)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linFrameConfig(object):
    """
    Attributes:
     - frameId: int32
    	LIN报文ID信息
     - frameName: string
    	LIN报文名字
     - channel: int32
    	LIN报文所在软件通道信息
     - simu: bool
    	LIN报文是否仿真标志位

    """


    def __init__(self, frameId=None, frameName=None, channel=None, simu=None,):
        self.frameId = frameId
        self.frameName = frameName
        self.channel = channel
        self.simu = simu

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.frameId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.frameName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.channel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.simu = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linFrameConfig')
        if self.frameId is not None:
            oprot.writeFieldBegin('frameId', TType.I32, 1)
            oprot.writeI32(self.frameId)
            oprot.writeFieldEnd()
        if self.frameName is not None:
            oprot.writeFieldBegin('frameName', TType.STRING, 2)
            oprot.writeString(self.frameName.encode('utf-8') if sys.version_info[0] == 2 else self.frameName)
            oprot.writeFieldEnd()
        if self.channel is not None:
            oprot.writeFieldBegin('channel', TType.I32, 3)
            oprot.writeI32(self.channel)
            oprot.writeFieldEnd()
        if self.simu is not None:
            oprot.writeFieldBegin('simu', TType.BOOL, 4)
            oprot.writeBool(self.simu)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linFrameData(object):
    """
    Attributes:
     - frameId: int32
    	LIN报文ID
     - frameName: string
    	LIN报文名字
     - channel: int32
    	LIN报文所在软件通道信息
     - setData: string
    	LIN数据，例如{sig1:1,sig2:1},然后使用json.dumps转换成string
     - encodeType: string
    	LIN数据序列化方式，支持两种 'raw','unraw'

    """


    def __init__(self, frameId=None, frameName=None, channel=None, setData=None, encodeType=None,):
        self.frameId = frameId
        self.frameName = frameName
        self.channel = channel
        self.setData = setData
        self.encodeType = encodeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.frameId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.frameName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.channel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.setData = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.encodeType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linFrameData')
        if self.frameId is not None:
            oprot.writeFieldBegin('frameId', TType.I32, 1)
            oprot.writeI32(self.frameId)
            oprot.writeFieldEnd()
        if self.frameName is not None:
            oprot.writeFieldBegin('frameName', TType.STRING, 2)
            oprot.writeString(self.frameName.encode('utf-8') if sys.version_info[0] == 2 else self.frameName)
            oprot.writeFieldEnd()
        if self.channel is not None:
            oprot.writeFieldBegin('channel', TType.I32, 3)
            oprot.writeI32(self.channel)
            oprot.writeFieldEnd()
        if self.setData is not None:
            oprot.writeFieldBegin('setData', TType.STRING, 4)
            oprot.writeString(self.setData.encode('utf-8') if sys.version_info[0] == 2 else self.setData)
            oprot.writeFieldEnd()
        if self.encodeType is not None:
            oprot.writeFieldBegin('encodeType', TType.STRING, 5)
            oprot.writeString(self.encodeType.encode('utf-8') if sys.version_info[0] == 2 else self.encodeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linSignalData(object):
    """
    Attributes:
     - signalName: string
    	LIN信号名字
     - channel: int32
    	LIN报文所在软件通道信息
     - setData: string
    	LIN数据，使用json.dumps转换成string
     - encodeType: string
    	LIN数据序列化方式，支持两种 'raw','unraw'

    """


    def __init__(self, signalName=None, channel=None, setData=None, encodeType=None,):
        self.signalName = signalName
        self.channel = channel
        self.setData = setData
        self.encodeType = encodeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signalName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.channel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.setData = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.encodeType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linSignalData')
        if self.signalName is not None:
            oprot.writeFieldBegin('signalName', TType.STRING, 1)
            oprot.writeString(self.signalName.encode('utf-8') if sys.version_info[0] == 2 else self.signalName)
            oprot.writeFieldEnd()
        if self.channel is not None:
            oprot.writeFieldBegin('channel', TType.I32, 2)
            oprot.writeI32(self.channel)
            oprot.writeFieldEnd()
        if self.setData is not None:
            oprot.writeFieldBegin('setData', TType.STRING, 3)
            oprot.writeString(self.setData.encode('utf-8') if sys.version_info[0] == 2 else self.setData)
            oprot.writeFieldEnd()
        if self.encodeType is not None:
            oprot.writeFieldBegin('encodeType', TType.STRING, 4)
            oprot.writeString(self.encodeType.encode('utf-8') if sys.version_info[0] == 2 else self.encodeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linParserStatus(object):
    """
    Attributes:
     - result
     - status
     - strStatus

    """


    def __init__(self, result=None, status=None, strStatus=None,):
        self.result = result
        self.status = status
        self.strStatus = strStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = CommonNode_ttypes.result()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strStatus = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linParserStatus')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 2)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.strStatus is not None:
            oprot.writeFieldBegin('strStatus', TType.STRING, 3)
            oprot.writeString(self.strStatus.encode('utf-8') if sys.version_info[0] == 2 else self.strStatus)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linLdfJson(object):
    """
    Attributes:
     - result: int32
    	返回值，0是成功，非0是失败
     - reasonbinary: string
    	失败的理由
     - jsonData: string
    	成功后json数据

    """


    def __init__(self, result=None, reasonbinary=None, jsonData=None,):
        self.result = result
        self.reasonbinary = reasonbinary
        self.jsonData = jsonData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reasonbinary = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.jsonData = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linLdfJson')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.reasonbinary is not None:
            oprot.writeFieldBegin('reasonbinary', TType.STRING, 2)
            oprot.writeString(self.reasonbinary.encode('utf-8') if sys.version_info[0] == 2 else self.reasonbinary)
            oprot.writeFieldEnd()
        if self.jsonData is not None:
            oprot.writeFieldBegin('jsonData', TType.STRING, 3)
            oprot.writeString(self.jsonData.encode('utf-8') if sys.version_info[0] == 2 else self.jsonData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class convertInput(object):
    """
    Attributes:
     - srcFile: string
    	源文件地址
     - dstFile: string
    	目标文件地址

    """


    def __init__(self, srcFile=None, dstFile=None,):
        self.srcFile = srcFile
        self.dstFile = dstFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.srcFile = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dstFile = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertInput')
        if self.srcFile is not None:
            oprot.writeFieldBegin('srcFile', TType.STRING, 1)
            oprot.writeString(self.srcFile.encode('utf-8') if sys.version_info[0] == 2 else self.srcFile)
            oprot.writeFieldEnd()
        if self.dstFile is not None:
            oprot.writeFieldBegin('dstFile', TType.STRING, 2)
            oprot.writeString(self.dstFile.encode('utf-8') if sys.version_info[0] == 2 else self.dstFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linCrcConfigParser(object):
    """
    Attributes:
     - channel: int32
    	需要设置CRC报文所在软件通道
     - frameId: int32
    	需要设置CRC报文ID
     - frameName: string
    	需要设置CRC报文名字
     - signalRcName: string
    	需要设置RC信号
     - signalCrcName: string
    	需要设置CRC信号
     - rcMin: int32
    	需要设置RC最小值
     - rcMax: int32
    	需要设置RC最大值
     - crcTable: list[int32]
    	CRC table
     - stepLen: int32
    	RC步长设置

    """


    def __init__(self, channel=None, frameId=None, frameName=None, signalRcName=None, signalCrcName=None, rcMin=None, rcMax=None, crcTable=None, stepLen=None,):
        self.channel = channel
        self.frameId = frameId
        self.frameName = frameName
        self.signalRcName = signalRcName
        self.signalCrcName = signalCrcName
        self.rcMin = rcMin
        self.rcMax = rcMax
        self.crcTable = crcTable
        self.stepLen = stepLen

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.channel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.frameId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.frameName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.signalRcName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.signalCrcName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.rcMin = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.rcMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.crcTable = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.crcTable.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.stepLen = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linCrcConfigParser')
        if self.channel is not None:
            oprot.writeFieldBegin('channel', TType.I32, 1)
            oprot.writeI32(self.channel)
            oprot.writeFieldEnd()
        if self.frameId is not None:
            oprot.writeFieldBegin('frameId', TType.I32, 2)
            oprot.writeI32(self.frameId)
            oprot.writeFieldEnd()
        if self.frameName is not None:
            oprot.writeFieldBegin('frameName', TType.STRING, 3)
            oprot.writeString(self.frameName.encode('utf-8') if sys.version_info[0] == 2 else self.frameName)
            oprot.writeFieldEnd()
        if self.signalRcName is not None:
            oprot.writeFieldBegin('signalRcName', TType.STRING, 4)
            oprot.writeString(self.signalRcName.encode('utf-8') if sys.version_info[0] == 2 else self.signalRcName)
            oprot.writeFieldEnd()
        if self.signalCrcName is not None:
            oprot.writeFieldBegin('signalCrcName', TType.STRING, 5)
            oprot.writeString(self.signalCrcName.encode('utf-8') if sys.version_info[0] == 2 else self.signalCrcName)
            oprot.writeFieldEnd()
        if self.rcMin is not None:
            oprot.writeFieldBegin('rcMin', TType.I32, 6)
            oprot.writeI32(self.rcMin)
            oprot.writeFieldEnd()
        if self.rcMax is not None:
            oprot.writeFieldBegin('rcMax', TType.I32, 7)
            oprot.writeI32(self.rcMax)
            oprot.writeFieldEnd()
        if self.crcTable is not None:
            oprot.writeFieldBegin('crcTable', TType.LIST, 8)
            oprot.writeListBegin(TType.I32, len(self.crcTable))
            for iter6 in self.crcTable:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.stepLen is not None:
            oprot.writeFieldBegin('stepLen', TType.I32, 9)
            oprot.writeI32(self.stepLen)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(linNodeConfig)
linNodeConfig.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nodeName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'channel', None, None, ),  # 2
    (3, TType.BOOL, 'simu', None, None, ),  # 3
)
all_structs.append(linFrameConfig)
linFrameConfig.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'frameId', None, None, ),  # 1
    (2, TType.STRING, 'frameName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'channel', None, None, ),  # 3
    (4, TType.BOOL, 'simu', None, None, ),  # 4
)
all_structs.append(linFrameData)
linFrameData.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'frameId', None, None, ),  # 1
    (2, TType.STRING, 'frameName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'channel', None, None, ),  # 3
    (4, TType.STRING, 'setData', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'encodeType', 'UTF8', None, ),  # 5
)
all_structs.append(linSignalData)
linSignalData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signalName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'channel', None, None, ),  # 2
    (3, TType.STRING, 'setData', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'encodeType', 'UTF8', None, ),  # 4
)
all_structs.append(linParserStatus)
linParserStatus.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [CommonNode_ttypes.result, None], None, ),  # 1
    (2, TType.I32, 'status', None, None, ),  # 2
    (3, TType.STRING, 'strStatus', 'UTF8', None, ),  # 3
)
all_structs.append(linLdfJson)
linLdfJson.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'reasonbinary', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'jsonData', 'UTF8', None, ),  # 3
)
all_structs.append(convertInput)
convertInput.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'srcFile', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dstFile', 'UTF8', None, ),  # 2
)
all_structs.append(linCrcConfigParser)
linCrcConfigParser.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'channel', None, None, ),  # 1
    (2, TType.I32, 'frameId', None, None, ),  # 2
    (3, TType.STRING, 'frameName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'signalRcName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'signalCrcName', 'UTF8', None, ),  # 5
    (6, TType.I32, 'rcMin', None, None, ),  # 6
    (7, TType.I32, 'rcMax', None, None, ),  # 7
    (8, TType.LIST, 'crcTable', (TType.I32, None, False), None, ),  # 8
    (9, TType.I32, 'stepLen', None, None, ),  # 9
)
fix_spec(all_structs)
del all_structs
