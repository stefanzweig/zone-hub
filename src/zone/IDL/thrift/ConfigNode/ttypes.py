#
# Autogenerated by Thrift Compiler (0.19.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
sys.path.append("..")
from zone.IDL.thrift.CommonNode import ttypes as CommonNode_ttypes
from zone.IDL.thrift.SomeIpNode import ttypes as SomeIpNode_ttypes

from thrift.transport import TTransport
all_structs = []


class hardwareType(object):
    """
    Attributes:
     - type: list[int32]
    	需要获取硬件品牌，vector 0x1;pcan 0x2;busmust 0x4;usbdevice 0x8;

    """


    def __init__(self, type=None,):
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.type = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.type.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hardwareType')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.type))
            for iter6 in self.type:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class channelInfo(object):
    """
    Attributes:
     - type: string
    	获取硬件类型，如CAN LIN Eth
     - name: list[string]
    	获取到硬件名字列表，如 [e.g. VN1640A 0 channel 1]

    """


    def __init__(self, type=None, name=None,):
        self.type = type
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.name = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.name.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('channelInfo')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 1)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.name))
            for iter13 in self.name:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class hardwareInfo(object):
    """
    Attributes:
     - hardwareType: string
    	获取硬件品牌名字，如Vector,PCAN,BUSMUST,USBDEVICE
     - channel: list[channelInfo]
    	该品牌硬件下所有通道信息

    """


    def __init__(self, hardwareType=None, channel=None,):
        self.hardwareType = hardwareType
        self.channel = channel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hardwareType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.channel = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = channelInfo()
                        _elem19.read(iprot)
                        self.channel.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hardwareInfo')
        if self.hardwareType is not None:
            oprot.writeFieldBegin('hardwareType', TType.STRING, 1)
            oprot.writeString(self.hardwareType.encode('utf-8') if sys.version_info[0] == 2 else self.hardwareType)
            oprot.writeFieldEnd()
        if self.channel is not None:
            oprot.writeFieldBegin('channel', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.channel))
            for iter20 in self.channel:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class hardwareInfos(object):
    """
    Attributes:
     - hardware: list[hardwareInfo]
    	获取到所有硬件信息

    """


    def __init__(self, hardware=None,):
        self.hardware = hardware

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.hardware = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = hardwareInfo()
                        _elem26.read(iprot)
                        self.hardware.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hardwareInfos')
        if self.hardware is not None:
            oprot.writeFieldBegin('hardware', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.hardware))
            for iter27 in self.hardware:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class dbPath(object):
    """
    Attributes:
     - dbPath: string
    	arxml路径信息

    """


    def __init__(self, dbPath=None,):
        self.dbPath = dbPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dbPath')
        if self.dbPath is not None:
            oprot.writeFieldBegin('dbPath', TType.STRING, 1)
            oprot.writeString(self.dbPath.encode('utf-8') if sys.version_info[0] == 2 else self.dbPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class canCluster(object):
    """
    Attributes:
     - cluster: list[string]
    	解析完arxml后返回所有通道名字信息

    """


    def __init__(self, cluster=None,):
        self.cluster = cluster

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cluster = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.cluster.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('canCluster')
        if self.cluster is not None:
            oprot.writeFieldBegin('cluster', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.cluster))
            for iter34 in self.cluster:
                oprot.writeString(iter34.encode('utf-8') if sys.version_info[0] == 2 else iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class canChannelInfo(object):
    """
    Attributes:
     - softwareChannel: int32
    	can软件通道信息
     - hardwareChannel: string
    	can硬件通道信息，该值通过getHardwareInfo返回中获取
     - databaseChannel: string
    	该通道需要配置的数据库通道，比如BDCAN
     - canType: int32
    	can通道类型，0代表CAN； 1代表CANFD
     - arbBitrate: int32
    	如果类型为CAN，该参数就是设置其波特率，如果类型为CANFD，该参数就是header波特率
     - dataBitrate: int32
    	如果类型为CAN，该参数忽略，如果类型为CANFD，该参数就是数据域波特率
     - sjwAbr: int32
    	同步跳转宽度，报文头
     - sjwDbr: int32
    	同步跳转宽度，数据场
     - tseg1Abr: int32
    	位时间段1，报文头
     - tseg1Dbr: int32
    	位时间段1，数据场
     - tseg2Abr: int32
    	位时间段2，报文头
     - tseg2Dbr: int32
    	位时间段2，数据场
     - txreceipts: int32
    	是否接收自己发送的报文
     - nsamplepos: int32
    	采样点
     - dsamplepos: int32
    	采样点
     - clockfreq: int32
    	时钟频率
     - dprescaler: int32
    	波特率分频器
     - nprescaler: int32
    	波特率分频器

    """


    def __init__(self, softwareChannel=None, hardwareChannel=None, databaseChannel=None, canType=None, arbBitrate=None, dataBitrate=None, sjwAbr=20, sjwDbr=5, tseg1Abr=59, tseg1Dbr=14, tseg2Abr=20, tseg2Dbr=5, txreceipts=1, nsamplepos=75, dsamplepos=75, clockfreq=80, dprescaler=2, nprescaler=2,):
        self.softwareChannel = softwareChannel
        self.hardwareChannel = hardwareChannel
        self.databaseChannel = databaseChannel
        self.canType = canType
        self.arbBitrate = arbBitrate
        self.dataBitrate = dataBitrate
        self.sjwAbr = sjwAbr
        self.sjwDbr = sjwDbr
        self.tseg1Abr = tseg1Abr
        self.tseg1Dbr = tseg1Dbr
        self.tseg2Abr = tseg2Abr
        self.tseg2Dbr = tseg2Dbr
        self.txreceipts = txreceipts
        self.nsamplepos = nsamplepos
        self.dsamplepos = dsamplepos
        self.clockfreq = clockfreq
        self.dprescaler = dprescaler
        self.nprescaler = nprescaler

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.softwareChannel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hardwareChannel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.databaseChannel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.canType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.arbBitrate = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.dataBitrate = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.sjwAbr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.sjwDbr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.tseg1Abr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.tseg1Dbr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.tseg2Abr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.tseg2Dbr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.txreceipts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I16:
                    self.nsamplepos = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I16:
                    self.dsamplepos = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I16:
                    self.clockfreq = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I16:
                    self.dprescaler = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I16:
                    self.nprescaler = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('canChannelInfo')
        if self.softwareChannel is not None:
            oprot.writeFieldBegin('softwareChannel', TType.I32, 1)
            oprot.writeI32(self.softwareChannel)
            oprot.writeFieldEnd()
        if self.hardwareChannel is not None:
            oprot.writeFieldBegin('hardwareChannel', TType.STRING, 2)
            oprot.writeString(self.hardwareChannel.encode('utf-8') if sys.version_info[0] == 2 else self.hardwareChannel)
            oprot.writeFieldEnd()
        if self.databaseChannel is not None:
            oprot.writeFieldBegin('databaseChannel', TType.STRING, 3)
            oprot.writeString(self.databaseChannel.encode('utf-8') if sys.version_info[0] == 2 else self.databaseChannel)
            oprot.writeFieldEnd()
        if self.canType is not None:
            oprot.writeFieldBegin('canType', TType.I32, 4)
            oprot.writeI32(self.canType)
            oprot.writeFieldEnd()
        if self.arbBitrate is not None:
            oprot.writeFieldBegin('arbBitrate', TType.I32, 5)
            oprot.writeI32(self.arbBitrate)
            oprot.writeFieldEnd()
        if self.dataBitrate is not None:
            oprot.writeFieldBegin('dataBitrate', TType.I32, 6)
            oprot.writeI32(self.dataBitrate)
            oprot.writeFieldEnd()
        if self.sjwAbr is not None:
            oprot.writeFieldBegin('sjwAbr', TType.I32, 7)
            oprot.writeI32(self.sjwAbr)
            oprot.writeFieldEnd()
        if self.sjwDbr is not None:
            oprot.writeFieldBegin('sjwDbr', TType.I32, 8)
            oprot.writeI32(self.sjwDbr)
            oprot.writeFieldEnd()
        if self.tseg1Abr is not None:
            oprot.writeFieldBegin('tseg1Abr', TType.I32, 9)
            oprot.writeI32(self.tseg1Abr)
            oprot.writeFieldEnd()
        if self.tseg1Dbr is not None:
            oprot.writeFieldBegin('tseg1Dbr', TType.I32, 10)
            oprot.writeI32(self.tseg1Dbr)
            oprot.writeFieldEnd()
        if self.tseg2Abr is not None:
            oprot.writeFieldBegin('tseg2Abr', TType.I32, 11)
            oprot.writeI32(self.tseg2Abr)
            oprot.writeFieldEnd()
        if self.tseg2Dbr is not None:
            oprot.writeFieldBegin('tseg2Dbr', TType.I32, 12)
            oprot.writeI32(self.tseg2Dbr)
            oprot.writeFieldEnd()
        if self.txreceipts is not None:
            oprot.writeFieldBegin('txreceipts', TType.I32, 13)
            oprot.writeI32(self.txreceipts)
            oprot.writeFieldEnd()
        if self.nsamplepos is not None:
            oprot.writeFieldBegin('nsamplepos', TType.I16, 14)
            oprot.writeI16(self.nsamplepos)
            oprot.writeFieldEnd()
        if self.dsamplepos is not None:
            oprot.writeFieldBegin('dsamplepos', TType.I16, 15)
            oprot.writeI16(self.dsamplepos)
            oprot.writeFieldEnd()
        if self.clockfreq is not None:
            oprot.writeFieldBegin('clockfreq', TType.I16, 16)
            oprot.writeI16(self.clockfreq)
            oprot.writeFieldEnd()
        if self.dprescaler is not None:
            oprot.writeFieldBegin('dprescaler', TType.I16, 17)
            oprot.writeI16(self.dprescaler)
            oprot.writeFieldEnd()
        if self.nprescaler is not None:
            oprot.writeFieldBegin('nprescaler', TType.I16, 18)
            oprot.writeI16(self.nprescaler)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class canConfigInfo(object):
    """
    Attributes:
     - canConfigChannelInfo: list[canChannelInfo]
    	所有需要设置can通道信息的列表

    """


    def __init__(self, canConfigChannelInfo=None,):
        self.canConfigChannelInfo = canConfigChannelInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.canConfigChannelInfo = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = canChannelInfo()
                        _elem40.read(iprot)
                        self.canConfigChannelInfo.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('canConfigInfo')
        if self.canConfigChannelInfo is not None:
            oprot.writeFieldBegin('canConfigChannelInfo', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.canConfigChannelInfo))
            for iter41 in self.canConfigChannelInfo:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hardwareType)
hardwareType.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'type', (TType.I32, None, False), None, ),  # 1
)
all_structs.append(channelInfo)
channelInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'type', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'name', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(hardwareInfo)
hardwareInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hardwareType', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'channel', (TType.STRUCT, [channelInfo, None], False), None, ),  # 2
)
all_structs.append(hardwareInfos)
hardwareInfos.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'hardware', (TType.STRUCT, [hardwareInfo, None], False), None, ),  # 1
)
all_structs.append(dbPath)
dbPath.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbPath', 'UTF8', None, ),  # 1
)
all_structs.append(canCluster)
canCluster.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cluster', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(canChannelInfo)
canChannelInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'softwareChannel', None, None, ),  # 1
    (2, TType.STRING, 'hardwareChannel', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'databaseChannel', 'UTF8', None, ),  # 3
    (4, TType.I32, 'canType', None, None, ),  # 4
    (5, TType.I32, 'arbBitrate', None, None, ),  # 5
    (6, TType.I32, 'dataBitrate', None, None, ),  # 6
    (7, TType.I32, 'sjwAbr', None, 20, ),  # 7
    (8, TType.I32, 'sjwDbr', None, 5, ),  # 8
    (9, TType.I32, 'tseg1Abr', None, 59, ),  # 9
    (10, TType.I32, 'tseg1Dbr', None, 14, ),  # 10
    (11, TType.I32, 'tseg2Abr', None, 20, ),  # 11
    (12, TType.I32, 'tseg2Dbr', None, 5, ),  # 12
    (13, TType.I32, 'txreceipts', None, 1, ),  # 13
    (14, TType.I16, 'nsamplepos', None, 75, ),  # 14
    (15, TType.I16, 'dsamplepos', None, 75, ),  # 15
    (16, TType.I16, 'clockfreq', None, 80, ),  # 16
    (17, TType.I16, 'dprescaler', None, 2, ),  # 17
    (18, TType.I16, 'nprescaler', None, 2, ),  # 18
)
all_structs.append(canConfigInfo)
canConfigInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'canConfigChannelInfo', (TType.STRUCT, [canChannelInfo, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
