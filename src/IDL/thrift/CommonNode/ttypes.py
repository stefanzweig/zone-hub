#
# Autogenerated by Thrift Compiler (0.19.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class eTHDEVICE(object):
    """

    以太网设备的类型，后面不断在这里追加
    eTHDEVICEPC 本机电脑
    eTHDEVICEVECTOR vector网卡

    """
    eTHDEVICEPC = 0
    eTHDEVICEVECTOR = 1

    _VALUES_TO_NAMES = {
        0: "eTHDEVICEPC",
        1: "eTHDEVICEVECTOR",
    }

    _NAMES_TO_VALUES = {
        "eTHDEVICEPC": 0,
        "eTHDEVICEVECTOR": 1,
    }


class ZSDEVICE(object):
    """

    ZoneMaster支持硬件类型，后面不断在这里追加
    VECTOR  vector设备
    PEAK 包括PCAN,PLIN目前不支持
    USBDEVICE 目前支持USB_LIN
    FIRE2 英特佩斯硬件

    """
    VECTOR = 0
    PEAK = 2
    BMMUST = 4
    USBDEVICE = 8
    FIRE2 = 16

    _VALUES_TO_NAMES = {
        0: "VECTOR",
        2: "PEAK",
        4: "BMMUST",
        8: "USBDEVICE",
        16: "FIRE2",
    }

    _NAMES_TO_VALUES = {
        "VECTOR": 0,
        "PEAK": 2,
        "BMMUST": 4,
        "USBDEVICE": 8,
        "FIRE2": 16,
    }


class result(object):
    """

    执行结果


    Attributes:
     - result: int32
    	执行结果状态值
     - reason: string
    	执行结果原因

    """


    def __init__(self, result=None, reason=None,):
        self.result = result
        self.reason = reason

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('result')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 2)
            oprot.writeString(self.reason.encode('utf-8') if sys.version_info[0] == 2 else self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class empty(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('empty')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class version(object):
    """

    版本


    Attributes:
     - version: string
    	版本信息
     - releaseDate: string
    	版本释放日期

    """


    def __init__(self, version=None, releaseDate=None,):
        self.version = version
        self.releaseDate = releaseDate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.releaseDate = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('version')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.releaseDate is not None:
            oprot.writeFieldBegin('releaseDate', TType.STRING, 2)
            oprot.writeString(self.releaseDate.encode('utf-8') if sys.version_info[0] == 2 else self.releaseDate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class arpPair(object):
    """

    arp信息表


    Attributes:
     - ipAddress: list[int32]
    	ip地址信息
     - macAddress: list[int32]
    	mac地址信息

    """


    def __init__(self, ipAddress=None, macAddress=None,):
        self.ipAddress = ipAddress
        self.macAddress = macAddress

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ipAddress = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.ipAddress.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.macAddress = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.macAddress.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arpPair')
        if self.ipAddress is not None:
            oprot.writeFieldBegin('ipAddress', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.ipAddress))
            for iter12 in self.ipAddress:
                oprot.writeI32(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.macAddress is not None:
            oprot.writeFieldBegin('macAddress', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.macAddress))
            for iter13 in self.macAddress:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class netInfo(object):
    """

    网卡信息


    Attributes:
     - ipAddr: string
    	网卡IP地址信息，例如'172.31.3.2'
     - iface: string
    	网卡名字，例如'以太网 1'
     - status: int32
    	网卡状态值
     - channel: int32
    	网卡设置通道
     - macAddress: list[int32]
    	mac地址信息，目前vector网卡需要设置，本机网卡无需设置，只需要在电脑本机以太网配置即可
     - mask: list[int32]
    	子网掩码信息，目前vector网卡需要设置，本机网卡无需设置，只需要在电脑本机以太网配置即可
     - virtualPort: string
    	虚拟port名字，目前vector网卡需要设置，本机网卡无需设置
     - switch: string
    	vector网卡所在switch名字，目前vector网卡需要设置，本机网卡无需设置
     - ethernetName: string
    	vector网卡所在Ethernet名字，目前vector网卡需要设置，本机网卡无需设置
     - igmpAddress: list[int32]
    	网卡IGMP信息，目前vector网卡需要设置，本机网卡无需设置
     - gateway: list[int32]
    	网卡网关信息，目前vector网卡需要设置，本机网卡无需设置
     - vlan: int32
    	网卡VLAN信息，目前vector网卡需要设置，本机网卡无需设置
     - arpPairs: list[arpPair]
    	网卡arp信息，目前vector网卡需要设置，本机网卡无需设置

    """


    def __init__(self, ipAddr=None, iface=None, status=None, channel=None, macAddress=None, mask=None, virtualPort=None, switch=None, ethernetName=None, igmpAddress=None, gateway=None, vlan=None, arpPairs=None,):
        self.ipAddr = ipAddr
        self.iface = iface
        self.status = status
        self.channel = channel
        self.macAddress = macAddress
        self.mask = mask
        self.virtualPort = virtualPort
        self.switch = switch
        self.ethernetName = ethernetName
        self.igmpAddress = igmpAddress
        self.gateway = gateway
        self.vlan = vlan
        self.arpPairs = arpPairs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipAddr = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.iface = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.channel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.macAddress = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI32()
                        self.macAddress.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.mask = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readI32()
                        self.mask.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.virtualPort = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.switch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.ethernetName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.igmpAddress = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = iprot.readI32()
                        self.igmpAddress.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.gateway = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = iprot.readI32()
                        self.gateway.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.vlan = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.arpPairs = []
                    (_etype41, _size38) = iprot.readListBegin()
                    for _i42 in range(_size38):
                        _elem43 = arpPair()
                        _elem43.read(iprot)
                        self.arpPairs.append(_elem43)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('netInfo')
        if self.ipAddr is not None:
            oprot.writeFieldBegin('ipAddr', TType.STRING, 1)
            oprot.writeString(self.ipAddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipAddr)
            oprot.writeFieldEnd()
        if self.iface is not None:
            oprot.writeFieldBegin('iface', TType.STRING, 2)
            oprot.writeString(self.iface.encode('utf-8') if sys.version_info[0] == 2 else self.iface)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 3)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.channel is not None:
            oprot.writeFieldBegin('channel', TType.I32, 4)
            oprot.writeI32(self.channel)
            oprot.writeFieldEnd()
        if self.macAddress is not None:
            oprot.writeFieldBegin('macAddress', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.macAddress))
            for iter44 in self.macAddress:
                oprot.writeI32(iter44)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mask is not None:
            oprot.writeFieldBegin('mask', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.mask))
            for iter45 in self.mask:
                oprot.writeI32(iter45)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.virtualPort is not None:
            oprot.writeFieldBegin('virtualPort', TType.STRING, 7)
            oprot.writeString(self.virtualPort.encode('utf-8') if sys.version_info[0] == 2 else self.virtualPort)
            oprot.writeFieldEnd()
        if self.switch is not None:
            oprot.writeFieldBegin('switch', TType.STRING, 8)
            oprot.writeString(self.switch.encode('utf-8') if sys.version_info[0] == 2 else self.switch)
            oprot.writeFieldEnd()
        if self.ethernetName is not None:
            oprot.writeFieldBegin('ethernetName', TType.STRING, 9)
            oprot.writeString(self.ethernetName.encode('utf-8') if sys.version_info[0] == 2 else self.ethernetName)
            oprot.writeFieldEnd()
        if self.igmpAddress is not None:
            oprot.writeFieldBegin('igmpAddress', TType.LIST, 10)
            oprot.writeListBegin(TType.I32, len(self.igmpAddress))
            for iter46 in self.igmpAddress:
                oprot.writeI32(iter46)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.gateway is not None:
            oprot.writeFieldBegin('gateway', TType.LIST, 11)
            oprot.writeListBegin(TType.I32, len(self.gateway))
            for iter47 in self.gateway:
                oprot.writeI32(iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vlan is not None:
            oprot.writeFieldBegin('vlan', TType.I32, 13)
            oprot.writeI32(self.vlan)
            oprot.writeFieldEnd()
        if self.arpPairs is not None:
            oprot.writeFieldBegin('arpPairs', TType.LIST, 14)
            oprot.writeListBegin(TType.STRUCT, len(self.arpPairs))
            for iter48 in self.arpPairs:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class filePath(object):
    """

    文件地址，也可以当作普通字符串使用


    Attributes:
     - path: string
    	文件地址信息，普通字符串

    """


    def __init__(self, path=None,):
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('filePath')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class folderFilePath(object):
    """

    文件夹和文件名地址


    Attributes:
     - folder: string
    	文件夹信息，普通字符串
     - file: string
    	文件地址信息，普通字符串

    """


    def __init__(self, folder=None, file=None,):
        self.folder = folder
        self.file = file

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.folder = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('folderFilePath')
        if self.folder is not None:
            oprot.writeFieldBegin('folder', TType.STRING, 1)
            oprot.writeString(self.folder.encode('utf-8') if sys.version_info[0] == 2 else self.folder)
            oprot.writeFieldEnd()
        if self.file is not None:
            oprot.writeFieldBegin('file', TType.STRING, 2)
            oprot.writeString(self.file.encode('utf-8') if sys.version_info[0] == 2 else self.file)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class genericString(object):
    """

    字符串加result结构组合


    Attributes:
     - result: result
    	执行结果得数据结构，引用本文件中result
     - text: string
    	普通字符串，传递需要的信息

    """


    def __init__(self, result=None, text=None,):
        self.result = result
        self.text = text

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = result()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.text = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('genericString')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.text is not None:
            oprot.writeFieldBegin('text', TType.STRING, 2)
            oprot.writeString(self.text.encode('utf-8') if sys.version_info[0] == 2 else self.text)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class genericInt(object):
    """

    普通32位整型


    Attributes:
     - index: int32
    	普通整型，传递需的信息

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('genericInt')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class genericInt64(object):
    """

    普通64位整型


    Attributes:
     - index: int64
    	普通整型，传递需的信息

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.index = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('genericInt64')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I64, 1)
            oprot.writeI64(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linChannelInfo(object):
    """

    LIN 通道信息


    Attributes:
     - softwareChannel: int32
    	LIN 软件通道信息，软件通道用户自己定义，此通道用于报文通道定义，包括trace报文中通道信息
     - hardwareChannel: string
    	LIN 硬件通道信息，硬件通道信息为读取到的硬件信息，如vector 'VN1640 123434 1',1640+序列号+通道
     - databaseChannel: string
    	LIN 加载数据库路径，需要绝对路径
     - isMaster: int32
    	LIN 通道模式，是否作为主节点模式，1表示主节点模式，0表示从节点模式
     - bitrate: int32
    	LIN 通道波特率，一般设置192000
     - deviceId: int32
    	vector设备不用设置，该参数用于USB_LIN PC识别COM的index
     - combaudrate: int64
    	该参数用于USB_LIN 与 PC 间通信波特率设置
     - major_version: int32
    	LIN 主版本信息
     - minor_version: int32
    	LIN 小版本信息
     - txreceipts: int32
    	LIN 是否接收自身发送的报文，1表示接收，0表示不接收
     - DLC: list[int8]
    	LIN 所有报文（ID：1-64）DLC信息，LIN解析节点设置不需要设置，LIN发送节点需要设置，如不设置全部按照DLC=8
     - hardwareType: int16
    	LIN 硬件类型，可以查看枚举ZSDEVICE信息
     - appname: string
    	vector设备需要设置
     - initData: list[int8]
    	LIN 所有报文初始值信息，此初始值对应id初始值字典，如{1：[0,1,2,3]}，然后将该字典转化bytes后转成list[int8]
     - id: list[int8]
    	调度表中对应ID列表，顺序也需要和调度表一致，LIN解析节点设置时不需要，发送节点需要设置
     - time: list[int8]
    	调度表中对应ID后的时间，顺序也需要和调度表一致，LIN解析节点设置时不需要，发送节点需要设置
    	此time是对应id的调度表时间,因为时间事float类型需要将该列表转化成bytes,然后转成list进行发送

    """


    def __init__(self, softwareChannel=None, hardwareChannel=None, databaseChannel=None, isMaster=0, bitrate=0, deviceId=0, combaudrate=19200, major_version=2, minor_version=1, txreceipts=1, DLC=[
    ], hardwareType=0, appname=None, initData=[
    ], id=[
    ], time=[
    ],):
        self.softwareChannel = softwareChannel
        self.hardwareChannel = hardwareChannel
        self.databaseChannel = databaseChannel
        self.isMaster = isMaster
        self.bitrate = bitrate
        self.deviceId = deviceId
        self.combaudrate = combaudrate
        self.major_version = major_version
        self.minor_version = minor_version
        self.txreceipts = txreceipts
        if DLC is self.thrift_spec[11][4]:
            DLC = [
            ]
        self.DLC = DLC
        self.hardwareType = hardwareType
        self.appname = appname
        if initData is self.thrift_spec[14][4]:
            initData = [
            ]
        self.initData = initData
        if id is self.thrift_spec[15][4]:
            id = [
            ]
        self.id = id
        if time is self.thrift_spec[16][4]:
            time = [
            ]
        self.time = time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.softwareChannel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hardwareChannel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.databaseChannel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.isMaster = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.bitrate = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.deviceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.combaudrate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.major_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.minor_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.txreceipts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.DLC = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readByte()
                        self.DLC.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I16:
                    self.hardwareType = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.appname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.initData = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readByte()
                        self.initData.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.id = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = iprot.readByte()
                        self.id.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.time = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readByte()
                        self.time.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linChannelInfo')
        if self.softwareChannel is not None:
            oprot.writeFieldBegin('softwareChannel', TType.I32, 1)
            oprot.writeI32(self.softwareChannel)
            oprot.writeFieldEnd()
        if self.hardwareChannel is not None:
            oprot.writeFieldBegin('hardwareChannel', TType.STRING, 2)
            oprot.writeString(self.hardwareChannel.encode('utf-8') if sys.version_info[0] == 2 else self.hardwareChannel)
            oprot.writeFieldEnd()
        if self.databaseChannel is not None:
            oprot.writeFieldBegin('databaseChannel', TType.STRING, 3)
            oprot.writeString(self.databaseChannel.encode('utf-8') if sys.version_info[0] == 2 else self.databaseChannel)
            oprot.writeFieldEnd()
        if self.isMaster is not None:
            oprot.writeFieldBegin('isMaster', TType.I32, 4)
            oprot.writeI32(self.isMaster)
            oprot.writeFieldEnd()
        if self.bitrate is not None:
            oprot.writeFieldBegin('bitrate', TType.I32, 5)
            oprot.writeI32(self.bitrate)
            oprot.writeFieldEnd()
        if self.deviceId is not None:
            oprot.writeFieldBegin('deviceId', TType.I32, 6)
            oprot.writeI32(self.deviceId)
            oprot.writeFieldEnd()
        if self.combaudrate is not None:
            oprot.writeFieldBegin('combaudrate', TType.I64, 7)
            oprot.writeI64(self.combaudrate)
            oprot.writeFieldEnd()
        if self.major_version is not None:
            oprot.writeFieldBegin('major_version', TType.I32, 8)
            oprot.writeI32(self.major_version)
            oprot.writeFieldEnd()
        if self.minor_version is not None:
            oprot.writeFieldBegin('minor_version', TType.I32, 9)
            oprot.writeI32(self.minor_version)
            oprot.writeFieldEnd()
        if self.txreceipts is not None:
            oprot.writeFieldBegin('txreceipts', TType.I32, 10)
            oprot.writeI32(self.txreceipts)
            oprot.writeFieldEnd()
        if self.DLC is not None:
            oprot.writeFieldBegin('DLC', TType.LIST, 11)
            oprot.writeListBegin(TType.BYTE, len(self.DLC))
            for iter73 in self.DLC:
                oprot.writeByte(iter73)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hardwareType is not None:
            oprot.writeFieldBegin('hardwareType', TType.I16, 12)
            oprot.writeI16(self.hardwareType)
            oprot.writeFieldEnd()
        if self.appname is not None:
            oprot.writeFieldBegin('appname', TType.STRING, 13)
            oprot.writeString(self.appname.encode('utf-8') if sys.version_info[0] == 2 else self.appname)
            oprot.writeFieldEnd()
        if self.initData is not None:
            oprot.writeFieldBegin('initData', TType.LIST, 14)
            oprot.writeListBegin(TType.BYTE, len(self.initData))
            for iter74 in self.initData:
                oprot.writeByte(iter74)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.LIST, 15)
            oprot.writeListBegin(TType.BYTE, len(self.id))
            for iter75 in self.id:
                oprot.writeByte(iter75)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.LIST, 16)
            oprot.writeListBegin(TType.BYTE, len(self.time))
            for iter76 in self.time:
                oprot.writeByte(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linChannelConfigs(object):
    """
    Attributes:
     - linChannelConfigs: list[linChannelInfo]
    	多条LIN配置，list中元素为本文件中linChannelInfo

    """


    def __init__(self, linChannelConfigs=None,):
        self.linChannelConfigs = linChannelConfigs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.linChannelConfigs = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = linChannelInfo()
                        _elem82.read(iprot)
                        self.linChannelConfigs.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('linChannelConfigs')
        if self.linChannelConfigs is not None:
            oprot.writeFieldBegin('linChannelConfigs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.linChannelConfigs))
            for iter83 in self.linChannelConfigs:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(result)
result.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'reason', 'UTF8', None, ),  # 2
)
all_structs.append(empty)
empty.thrift_spec = (
)
all_structs.append(version)
version.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'releaseDate', 'UTF8', None, ),  # 2
)
all_structs.append(arpPair)
arpPair.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ipAddress', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'macAddress', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(netInfo)
netInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipAddr', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'iface', 'UTF8', None, ),  # 2
    (3, TType.I32, 'status', None, None, ),  # 3
    (4, TType.I32, 'channel', None, None, ),  # 4
    (5, TType.LIST, 'macAddress', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'mask', (TType.I32, None, False), None, ),  # 6
    (7, TType.STRING, 'virtualPort', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'switch', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'ethernetName', 'UTF8', None, ),  # 9
    (10, TType.LIST, 'igmpAddress', (TType.I32, None, False), None, ),  # 10
    (11, TType.LIST, 'gateway', (TType.I32, None, False), None, ),  # 11
    None,  # 12
    (13, TType.I32, 'vlan', None, None, ),  # 13
    (14, TType.LIST, 'arpPairs', (TType.STRUCT, [arpPair, None], False), None, ),  # 14
)
all_structs.append(filePath)
filePath.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
)
all_structs.append(folderFilePath)
folderFilePath.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'folder', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'file', 'UTF8', None, ),  # 2
)
all_structs.append(genericString)
genericString.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [result, None], None, ),  # 1
    (2, TType.STRING, 'text', 'UTF8', None, ),  # 2
)
all_structs.append(genericInt)
genericInt.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
)
all_structs.append(genericInt64)
genericInt64.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'index', None, None, ),  # 1
)
all_structs.append(linChannelInfo)
linChannelInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'softwareChannel', None, None, ),  # 1
    (2, TType.STRING, 'hardwareChannel', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'databaseChannel', 'UTF8', None, ),  # 3
    (4, TType.I32, 'isMaster', None, 0, ),  # 4
    (5, TType.I32, 'bitrate', None, 0, ),  # 5
    (6, TType.I32, 'deviceId', None, 0, ),  # 6
    (7, TType.I64, 'combaudrate', None, 19200, ),  # 7
    (8, TType.I32, 'major_version', None, 2, ),  # 8
    (9, TType.I32, 'minor_version', None, 1, ),  # 9
    (10, TType.I32, 'txreceipts', None, 1, ),  # 10
    (11, TType.LIST, 'DLC', (TType.BYTE, None, False), [
    ], ),  # 11
    (12, TType.I16, 'hardwareType', None, 0, ),  # 12
    (13, TType.STRING, 'appname', 'UTF8', None, ),  # 13
    (14, TType.LIST, 'initData', (TType.BYTE, None, False), [
    ], ),  # 14
    (15, TType.LIST, 'id', (TType.BYTE, None, False), [
    ], ),  # 15
    (16, TType.LIST, 'time', (TType.BYTE, None, False), [
    ], ),  # 16
)
all_structs.append(linChannelConfigs)
linChannelConfigs.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'linChannelConfigs', (TType.STRUCT, [linChannelInfo, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
